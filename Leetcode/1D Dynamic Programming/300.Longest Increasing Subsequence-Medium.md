## Question:

Given an integer array nums, return the length of the longest strictly increasing subsequence.  

Example 1:  

Input: nums = [10,9,2,5,3,7,101,18]  
Output: 4  

Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.  

Example 2:  

Input: nums = [0,1,0,3,2,3]  
Output: 4  

Example 3:  

Input: nums = [7,7,7,7,7,7,7]  
Output: 1  

Constraints:  

1 <= nums.length <= 2500  
-104 <= nums[i] <= 104  
 
Follow up: Can you come up with an algorithm that runs in O(n log(n)) time complexity?  

---
## Thought:
We use 1d dp to do it.

This Java code implements a solution to the "Longest Increasing Subsequence" (LIS) problem using dynamic programming. The goal is to find the length of the longest subsequence of a given array where the elements are in increasing order:  

Initialization:  
An array dp of the same length as nums is initialized, where each element is set to 1. This is because the minimum length of an increasing subsequence that includes each element is 1 (the element itself).  
A variable result is initialized to 1 to track the maximum length of any increasing subsequence found.  

Dynamic Programming Solution:  
The outer loop iterates through the array nums starting from the second element (i=1 to nums.length - 1), considering each element as a potential end of an increasing subsequence.  
The inner loop iterates from the start of the array to the current element i, checking all possible preceding elements (j=0 to i-1).  
If nums[j] is less than nums[i], it indicates that the element at j can be part of an increasing subsequence ending at i. The dp[i] is updated to the maximum of its current value or dp[j] + 1 (extending the subsequence ending at j with the current element i).  
After evaluating all possible j for each i, result is updated to the maximum value in dp[i].  

Returning the Result:  
After filling the dp array, the result variable contains the length of the longest increasing subsequence in the array, which is returned as the output.  

This method effectively calculates the LIS by building up the solution using the subproblems of finding the longest subsequence up to each index, thus allowing the overall problem to be solved efficiently in O(n^2) time complexity due to the nested loops.

---
## Solution:
```Java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int[] dp = new int[nums.length];
        Arrays.fill(dp, 1);
        int result = 1;
        for(int i = 1; i < nums.length; i++){
            for(int j = 0; j < i; j++){
                int temp = 1;
                if(nums[j] < nums[i]){
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            result = Math.max(result, dp[i]);
        }

        return result;
    }
}
```
Time complexity: O(n<sup>2</sup>)  
Space complexity: O(n)
