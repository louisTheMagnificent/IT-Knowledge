## Question:

Given the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from position left to position right, and return the reversed list.
 
Example 1:

Input: head = [1,2,3,4,5], left = 2, right = 4
Output: [1,4,3,2,5]  

Example 2:

Input: head = [5], left = 1, right = 1
Output: [5]

Constraints:

The number of nodes in the list is n.  
1 <= n <= 500  
-500 <= Node.val <= 500  
1 <= left <= right <= n  

Follow up: Could you do it in one pass?

## Thought:
We set three pointers: slow, fast and fastNext. First we create a dummyNode to point at the head. We keep moving slow and fast until 
the node of left - 1, we stop the slow and move fast to the left node. We set fastNext as fast's next node. Before the fast reaches the
right node, we get current node and move fast to fastNext, fastNext to its next (we need fastNext to track the previous fast's next node
because after adjusting, fast.next is changed into its previous node). We let fast.next as current. When fast reaches right, we let 
slow.next(left node).next as fastNext, and let slow.next as fast(right node). Then we return dummyNode.next.

---
## Solution:
```Java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode slow = dummy;
        ListNode fast = dummy;
        int count = 0;
        while(count != left - 1){
            fast = fast.next;
            slow = slow.next;
            count++;
        }
        fast = fast.next;
        count++;
        ListNode fastNext = fast.next;
        while(count != right){
            ListNode current = fast;
            fast = fastNext;
            fastNext = fastNext.next;
            count++;
            fast.next = current;
        }
        slow.next.next = fastNext;
        slow.next = fast;
        return dummy.next;
    }
}
```
Time complexity: O(n)  
Space complexity: O(1)
