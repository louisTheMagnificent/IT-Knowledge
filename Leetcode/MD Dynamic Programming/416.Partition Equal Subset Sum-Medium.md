## Question:

Given an integer array nums, return true if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or false otherwise.  

Example 1:  

Input: nums = [1,5,11,5]  
Output: true  

Explanation: The array can be partitioned as [1, 5, 5] and [11].  

Example 2:  

Input: nums = [1,2,3,5]  
Output: false  

Explanation: The array cannot be partitioned into equal sum subsets.  
 
Constraints:  

1 <= nums.length <= 200  
1 <= nums[i] <= 100  

---
## Thought 1: 
We use md dp to do it.



---
## Solution 1:
```Java
class Solution {
    public boolean canPartition(int[] nums) {
        if(nums.length == 1) return false;
        int sum = 0;
        for(int num : nums){
            sum += num;
        }

        if(sum % 2 == 1) return false;

        sum /= 2;

        int[][] dp = new int[nums.length][sum + 1];

        for(int j = nums[0]; j <= sum; j++){
            dp[0][j] = nums[0];
        }
        if(dp[0][sum] == sum) return true;

        for(int i = 1; i < nums.length; i++){
            for(int j = 0; j <= sum; j++){
                if(j < nums[i]){
                    dp[i][j] = dp[i - 1][j];
                }
                else{
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - nums[i]] + nums[i]);
                }
            }
            if(dp[i][sum] == sum) return true;
        }
        return false;
    }
}
```
Time complexity: O(n<sup>2<sup>)  
Space complexity: O(n)

---
## Thought 2:
We use md dp to do it.

This Java code defines a method canPartition in the Solution class to determine if an array can be partitioned into two subsets such that the sums of the elements in both subsets are equal. The method uses dynamic programming to approach this problem.  

The code starts by checking the basic conditions: if the array has only one element, it cannot be partitioned, so it returns false. Then, it calculates the total sum of the array. If the sum is odd, it cannot be evenly split into two equal parts, and hence returns false.  

The main computation begins by setting the target sum as half of the total sum. A 2D array dp is used where dp[i][j] stores the maximum sum achievable with the first i items that does not exceed j. The first row of the DP table is initialized with the value of the first element of the array for sums that are at least as large as this element.  

For each subsequent element in the array, the method fills the DP table row by row. If the current subset sum j is less than the current item nums[i], the DP value is carried over from the previous item. Otherwise, it calculates the maximum of not taking or taking the current item.  

The algorithm returns true as soon as any row in the DP table has a subset sum that matches half of the total array sum, indicating a valid partition is possible. If no such partition is found by the end of the loop, it returns false.

---
## Solution 2:
```Java
